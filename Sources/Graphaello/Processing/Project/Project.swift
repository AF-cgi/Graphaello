import Foundation
import PathKit
import CLIKit
import XcodeProj

struct Project {
    let path: CLIKit.Path
    private let xcodeProject: XcodeProj
    private let sourcesPath: PathKit.Path

    init(path: CLIKit.Path) throws {
        self.path = path
        xcodeProject = try XcodeProj(pathString: path.string)
        sourcesPath = .init(path.deletingLastComponent.string)
    }
}

extension Project {

    var fileName: String {
        return path.lastComponent
    }

}

extension Project {

    func files() throws -> [PathKit.Path] {
        return try xcodeProject
            .pbxproj
            .buildFiles
            .compactMap { try $0.file?.fullPath(sourceRoot: sourcesPath) }
    }

}

extension Project {

    private func save() throws {
        try xcodeProject.write(path: PathKit.Path(self.path.string))
    }

}

extension Project {

    func writeFile(name: String, content: String) throws {
        guard let data = content.data(using: .utf8) else { return }
        try writeFile(name: name, data: data)
    }

    func writeFile(name: String, data: Data) throws {
        let file = try path(for: name)
        try data.write(to: file.url)
    }

    private func path(for file: String) throws -> PathKit.Path {
        return try files()
            .first { $0.lastComponent == file } ?? create(file: file)
    }

    private func create(file: String) throws -> PathKit.Path {
        guard let group = try xcodeProject.pbxproj.rootProject()?.mainGroup,
            let mainPath = try group.fullPath(sourceRoot: sourcesPath) else { fatalError() }

        let path = mainPath + file
        try path.write("// here goes an autogenerated file")
        let file = try group.addFile(at: path, sourceRoot: sourcesPath)
        try xcodeProject.pbxproj.sourcesBuildPhases.forEach { buildPhase in
            _ = try buildPhase.add(file: file)
        }
        try save()
        return path
    }

}

extension Project {

    func addDependencyIfNotThere(name: String,
                                 productName: String,
                                 repositoryURL: String,
                                 version: XCRemoteSwiftPackageReference.VersionRequirement) throws -> Bool {

        guard let project = try xcodeProject.pbxproj.rootProject() else { return false }
        guard !project.packages.contains(where: { $0.name == name }) else { return false }
        let packages = try project.targets.map { target in
            try project.addSwiftPackage(repositoryURL: repositoryURL,
                                        productName: productName,
                                        versionRequirement: version,
                                        targetName: target.name)
        }
        try save()
        _ = packages
        return true
    }

}

extension Project {

    func addBuildPhaseIfNotThrere(name: String,
                                  code: String) throws -> Bool {

        let targets = xcodeProject.pbxproj.nativeTargets.filter { !$0.buildPhases.contains { $0.name() == name } }
        guard !targets.isEmpty else { return false }
        let phase = PBXShellScriptBuildPhase(name: name, shellPath: "/bin/sh", shellScript: code)
        xcodeProject.pbxproj.add(object: phase)

        targets.forEach { target in
            guard let indexOfCompile = target.buildPhases.firstIndex(where: { $0.type() == .sources }) else { return }
            target.buildPhases.insert(phase, at: indexOfCompile)
        }

        try save()
        return true
    }

}
