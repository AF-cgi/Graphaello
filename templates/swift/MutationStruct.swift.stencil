extension {{ structPrepared.name }} {
    class {{ mutationStruct.mutation.name }}{% if mutationStruct.mutation.referencedFragment %}<V: Fragment>{% endif %}: Mutation, ObservableObject{% if mutationStruct.mutation.referencedFragment %} where V.UnderlyingType == {{ swiftUnderlyingType }}{% endif %} {

        {% if mutationStruct.mutation.referencedFragment %}
        typealias Value = V
        {% else %}
        typealias Value = {{ swiftType }}
        {% endif %}

        @Published private var internalIsLoading = false
        private let subject = PassthroughSubject<Value, Error>()

        private let api: Todos

        var isLoading: Bool {
            return internalIsLoading
        }

        var value: AnyPublisher<Value, Error> {
            return subject.eraseToAnyPublisher()
        }
        
        init(api: {{ mutationStruct.mutation.api.name }}) {
            self.api = api
        }
    }
}

{% if mutationStruct.mutation.referencedFragment %}
extension {{ structPrepared.name }}.{{ mutationStruct.mutation.name }} where V == {{ swiftType }} {
{% else %}
extension {{ structPrepared.name }}.{{ mutationStruct.mutation.name }} {
{% endif %}

    @discardableResult
    func commit({{ queryRendererArguments|codeArray|join:", " }}) -> Self {
        internalIsLoading = true
        api.client.perform(mutation: Apollo{{ mutationStruct.mutation.api.name }}.{{ mutationStruct.mutation.name }}Mutation({{ queryArgumentAssignments|codeArray|join:", " }})) { result in
            self.internalIsLoading = false
            switch result {
            case let .success(response):
                guard let data = response.data else { return }
                self.subject.send({{ expression }})
            case let .failure(error):
                self.subject.send(completion: .failure(error))
            }
        }
        return self
    }

}
