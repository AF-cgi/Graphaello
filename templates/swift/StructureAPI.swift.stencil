// swiftlint:disable all
// This file was automatically generated and should not be edited.

import Apollo
import Foundation
import SwiftUI

// MARK: Basic API

private struct QueryRenderer<Query: GraphQLQuery, Content: View>: View {
    typealias ContentFactory = (Query.Data) -> Content

    let client: ApolloClient
    let query: Query
    let factory: ContentFactory
    
    @State private var isLoading: Bool = false
    @State private var value: Query.Data? = nil
    @State private var error: String? = nil
    @State private var cancellable: Cancellable? = nil
    
    var body: some View {
        return VStack {
            error.map { Text("Error: \($0)") }
            value.map(factory)
            isLoading ? Text("Loading") : nil
        }.onAppear {
            self.cancellable = self.client.fetch(query: self.query) { result in
                defer {
                    self.cancellable = nil
                    self.isLoading = false
                }
                switch result {
                case .success(let result):
                    self.value = result.data
                    self.error = result.errors?.map { $0.description }.joined(separator: ", ")
                case .failure(let error):
                    self.error = error.localizedDescription
                }
            }
            self.isLoading = true
        }.onDisappear {
            self.cancellable?.cancel()
        }
    }
}

protocol Fragment {
    associatedtype UnderlyingType
}

protocol Target { }

protocol API: Target { }

protocol Connection: Target {
    associatedtype Node
}

extension Array: Fragment where Element: Fragment {
    typealias UnderlyingType = [Element.UnderlyingType]
}

extension Optional: Fragment where Wrapped: Fragment {
    typealias UnderlyingType = Wrapped.UnderlyingType?
}

struct GraphQLPath<TargetType: Target, Value> {
    fileprivate init() { }
}

struct GraphQLFragmentPath<TargetType: Target, UnderlyingType> {
    fileprivate init() { }
}

extension GraphQLFragmentPath {
    typealias Path<V> = GraphQLPath<TargetType, V>
    typealias FragmentPath<V> = GraphQLFragmentPath<TargetType, V>
}

extension GraphQLFragmentPath {

    var _fragment: FragmentPath<UnderlyingType> {
        return self
    }

}

enum GraphQLArgument<Value> {
    enum QueryArgument {
        case withDefault(Value)
        case forced
    }

    case value(Value)
    case argument(QueryArgument)
}

extension GraphQLArgument {

    static var argument: GraphQLArgument<Value> {
        return .argument(.forced)
    }

    static func argument(default value: Value) -> GraphQLArgument<Value> {
        return .argument(.withDefault(value))
    }

}

struct Paging<Value: Fragment> {
    @State
    private(set) var isLoading: Bool = false

    @State
    private(set) var values: [Value]

    @State
    private var cursor: String

    @State
    private(set) var hasMore: Bool

    fileprivate init(values: [Value], cursor: String, hasMore: Bool) {
        self.values = values
        self.cursor = cursor
        self.hasMore = hasMore
    }
}

@propertyWrapper
struct GraphQL<Value> {
    var wrappedValue: Value

    init<T: Target>(_: @autoclosure () -> GraphQLPath<T, Value>) {
        fatalError("Initializer with path only should never be used")
    }

    fileprivate init(_ wrappedValue: Value) {
        self.wrappedValue = wrappedValue
    }
}

extension GraphQL where Value: Fragment {
    init<T: Target>(_: @autoclosure () -> GraphQLFragmentPath<T, Value.UnderlyingType>) {
        fatalError("Initializer with path only should never be used")
    }
}

extension GraphQL {
    init<T: API, C: Connection, F: Fragment>(_: @autoclosure () -> GraphQLFragmentPath<T, C>) where Value == Paging<F>, C.Node == F.UnderlyingType {
        fatalError("Initializer with path only should never be used")
    }

    init<T: API, C: Connection, F: Fragment>(_: @autoclosure () -> GraphQLFragmentPath<T, C?>) where Value == Paging<F>?, C.Node == F.UnderlyingType {
        fatalError("Initializer with path only should never be used")
    }
}

extension RawRepresentable {
    fileprivate init?<Other: RawRepresentable>(_ other: Other?) where Other.RawValue == RawValue {
        guard let rawValue = other?.rawValue else { return nil }
        self.init(rawValue: rawValue)
    }

    fileprivate init<Other: RawRepresentable>(_ other: Other) where Other.RawValue == RawValue {
        guard let value = Self(rawValue: other.rawValue) else { fatalError() }
        self = value
    }
}
