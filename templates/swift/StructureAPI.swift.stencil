// swiftlint:disable all
// This file was automatically generated and should not be edited.

import Apollo
import Foundation
import SwiftUI

// MARK: Basic API

private struct QueryRenderer<Query: GraphQLQuery, Content: View>: View {
    typealias ContentFactory = (Query.Data) -> Content

    let client: ApolloClient
    let query: Query
    let factory: ContentFactory
    
    @State private var isLoading: Bool = false
    @State private var value: Query.Data? = nil
    @State private var error: String? = nil
    @State private var cancellable: Cancellable? = nil
    
    var body: some View {
        return VStack {
            error.map { Text("Error: \($0)") }
            value.map(factory)
            isLoading ? Text("Loading") : nil
        }.onAppear {
            self.cancellable = self.client.fetch(query: self.query) { result in
                defer {
                    self.cancellable = nil
                    self.isLoading = false
                }
                switch result {
                case .success(let result):
                    self.value = result.data
                    self.error = result.errors?.map { $0.description }.joined(separator: ", ")
                case .failure(let error):
                    self.error = error.localizedDescription
                }
            }
            self.isLoading = true
        }.onDisappear {
            self.cancellable?.cancel()
        }
    }
}

protocol Fragment {
    associatedtype UnderlyingType
}

protocol Target { }

protocol API: Target { }

protocol Connection: Target {
    associatedtype Node
}

extension Array: Fragment where Element: Fragment {
    typealias UnderlyingType = [Element.UnderlyingType]
}

extension Optional: Fragment where Wrapped: Fragment {
    typealias UnderlyingType = Wrapped.UnderlyingType?
}

struct GraphQLPath<TargetType: Target, Value> {
    fileprivate init() { }
}

struct GraphQLFragmentPath<TargetType: Target, UnderlyingType> {
    fileprivate init() { }
}

extension GraphQLFragmentPath {
    typealias Path<V> = GraphQLPath<TargetType, V>
    typealias FragmentPath<V> = GraphQLFragmentPath<TargetType, V>
}

extension GraphQLFragmentPath {

    var _fragment: FragmentPath<UnderlyingType> {
        return self
    }

}

extension GraphQLFragmentPath {

    func _forEach<Value, Output>(_ keyPath: KeyPath<GraphQLFragmentPath<TargetType, Value>, GraphQLPath<TargetType, Output>>) -> GraphQLPath<TargetType, [Output]> where UnderlyingType == [Value] {
        return .init()
    }

    func _forEach<Value, Output>(_ keyPath: KeyPath<GraphQLFragmentPath<TargetType, Value>, GraphQLPath<TargetType, Output>>) -> GraphQLPath<TargetType, [Output]?> where UnderlyingType == [Value]? {
        return .init()
    }

}

extension GraphQLFragmentPath {


    func _forEach<Value, Output>(_ keyPath: KeyPath<GraphQLFragmentPath<TargetType, Value>, GraphQLFragmentPath<TargetType, Output>>) -> GraphQLFragmentPath<TargetType, [Output]> where UnderlyingType == [Value] {
        return .init()
    }

    func _forEach<Value, Output>(_ keyPath: KeyPath<GraphQLFragmentPath<TargetType, Value>, GraphQLFragmentPath<TargetType, Output>>) -> GraphQLFragmentPath<TargetType, [Output]?> where UnderlyingType == [Value]? {
        return .init()
    }

}

extension GraphQLPath {

    func _flatten<InnerValue>() -> GraphQLPath<TargetType, [InnerValue]> where Value == [[InnerValue]] {
        return .init()
    }

    func _flatten<InnerValue>() -> GraphQLPath<TargetType, [InnerValue]?> where Value == [[InnerValue]]? {
        return .init()
    }

}

extension GraphQLFragmentPath {

    func _flatten<Value>() -> GraphQLFragmentPath<TargetType, [Value]> where UnderlyingType == [[Value]] {
        return .init()
    }

    func _flatten<Value>() -> GraphQLFragmentPath<TargetType, [Value]?> where UnderlyingType == [[Value]]? {
        return .init()
    }

}

extension GraphQLPath {

    func _compactMap<InnerValue>() -> GraphQLPath<TargetType, [InnerValue]> where Value == [InnerValue?] {
        return .init()
    }

    func _compactMap<InnerValue>() -> GraphQLPath<TargetType, [InnerValue]?> where Value == [InnerValue?]? {
        return .init()
    }

}

extension GraphQLFragmentPath {

    func _compactMap<Value>() -> GraphQLFragmentPath<TargetType, [Value]> where UnderlyingType == [Value?] {
        return .init()
    }

    func _compactMap<Value>() -> GraphQLFragmentPath<TargetType, [Value]?> where UnderlyingType == [Value?]? {
        return .init()
    }

}

enum GraphQLArgument<Value> {
    enum QueryArgument {
        case withDefault(Value)
        case forced
    }

    case value(Value)
    case argument(QueryArgument)
}

extension GraphQLArgument {

    static var argument: GraphQLArgument<Value> {
        return .argument(.forced)
    }

    static func argument(default value: Value) -> GraphQLArgument<Value> {
        return .argument(.withDefault(value))
    }

}

class Paging<Value: Fragment>: DynamicProperty, ObservableObject {
    fileprivate struct Response {
        let values: [Value]
        let cursor: String?
        let hasMore: Bool

        static var empty: Response {
            Response(values: [], cursor: nil, hasMore: false)
        }
    }

    fileprivate typealias Completion = (Result<Response, Error>) -> Void
    fileprivate typealias Loader = (String, @escaping Completion) -> Void

    private let loader: Loader

    @Published
    private(set) var isLoading: Bool = false

    @Published
    private(set) var values: [Value] = []

    private var cursor: String?

    @Published
    private(set) var hasMore: Bool = false

    @Published
    private(set) var error: Error? = nil

    fileprivate init(_ response: Response, loader: @escaping Loader) {
        self.loader = loader
        use(response)
    }

    func loadMore() {
        guard let cursor = cursor, !isLoading else { return }
        isLoading = true
        loader(cursor) { [weak self] result in
            switch result {
            case let .success(response):
                self?.use(response)
            case let .failure(error):
                self?.handle(error)
            }
        }
    }

    private func use(_ response: Response) {
        isLoading = false
        values += response.values
        cursor = response.cursor
        hasMore = response.hasMore
    }

    private func handle(_ error: Error) {
        isLoading = false
        hasMore = false
        self.error = error
    }
}

struct PagingView<Value: Fragment>: View {
    enum Data {
        case item(Value, Int)
        case loading
        case error(Error)

        fileprivate var id: String {
            switch self {
            case .item(_, let int):
                return int.description
            case .error:
                return "error"
            case .loading:
                return "loading"
            }
        }
    }

    @ObservedObject private var paging: Paging<Value>
    private var loader: (Data) -> AnyView

    init(_ paging: Paging<Value>, loader: @escaping (Data) -> AnyView) {
        self.paging = paging
        self.loader = loader
    }

    var body: some View {
        ForEach((paging.values.enumerated().map { Data.item($0.element, $0.offset) } +
                    [paging.isLoading ? Data.loading : nil, paging.error.map(Data.error)].compactMap { $0 }),
                id: \.id) { data in

            self.loader(data).onAppear {  self.onAppear(data: data) }
        }
    }

    private func onAppear(data: Data) {
        guard !paging.isLoading,
            paging.hasMore,
            case .item(_, let index) = data,
            index > paging.values.count - 2 else { return }

        paging.loadMore()
    }
}

extension PagingView {

    init<Loading: View, Error: View, Data: View>(_ paging: Paging<Value>,
                                                 loading loadingView: @escaping () -> Loading,
                                                 error errorView: @escaping (Swift.Error) -> Error,
                                                 item itemView: @escaping (Value) -> Data) {

        self.init(paging) { data in
            switch data {
            case .item(let item, _):
                return AnyView(itemView(item))
            case .error(let error):
                return AnyView(errorView(error))
            case .loading:
                return AnyView(loadingView())
            }
        }
    }

    init<Error: View, Data: View>(_ paging: Paging<Value>,
                                  error errorView: @escaping (Swift.Error) -> Error,
                                  item itemView: @escaping (Value) -> Data) {

        self.init(paging,
                  loading: { Text("Loading") },
                  error: errorView,
                  item: itemView)
    }

    init<Loading: View, Data: View>(_ paging: Paging<Value>,
                                  loading loadingView: @escaping () -> Loading,
                                  item itemView: @escaping (Value) -> Data) {

        self.init(paging,
                  loading: loadingView,
                  error: { Text("Error: \($0.localizedDescription)") },
                  item: itemView)
    }

    init<Data: View>(_ paging: Paging<Value>,
                     item itemView: @escaping (Value) -> Data) {

        self.init(paging,
                  loading: { Text("Loading") },
                  error: { Text("Error: \($0.localizedDescription)") },
                  item: itemView)
    }

}

@propertyWrapper
struct GraphQL<Value> {
    var wrappedValue: Value

    init<T: Target>(_: @autoclosure () -> GraphQLPath<T, Value>) {
        fatalError("Initializer with path only should never be used")
    }

    fileprivate init(_ wrappedValue: Value) {
        self.wrappedValue = wrappedValue
    }
}

extension GraphQL where Value: Fragment {
    init<T: Target>(_: @autoclosure () -> GraphQLFragmentPath<T, Value.UnderlyingType>) {
        fatalError("Initializer with path only should never be used")
    }
}

extension GraphQL {
    init<T: API, C: Connection, F: Fragment>(_: @autoclosure () -> GraphQLFragmentPath<T, C>) where Value == Paging<F>, C.Node == F.UnderlyingType {
        fatalError("Initializer with path only should never be used")
    }

    init<T: API, C: Connection, F: Fragment>(_: @autoclosure () -> GraphQLFragmentPath<T, C?>) where Value == Paging<F>?, C.Node == F.UnderlyingType {
        fatalError("Initializer with path only should never be used")
    }
}

extension RawRepresentable {
    fileprivate init?<Other: RawRepresentable>(_ other: Other?) where Other.RawValue == RawValue {
        guard let rawValue = other?.rawValue else { return nil }
        self.init(rawValue: rawValue)
    }

    fileprivate init<Other: RawRepresentable>(_ other: Other) where Other.RawValue == RawValue {
        guard let value = Self(rawValue: other.rawValue) else { fatalError() }
        self = value
    }
}
